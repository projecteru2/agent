// Code generated by mockery v2.3.0. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	pb "github.com/projecteru2/core/rpc/gen"
)

// CoreRPCClient is an autogenerated mock type for the CoreRPCClient type
type CoreRPCClient struct {
	mock.Mock
}

// AddNode provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) AddNode(ctx context.Context, in *pb.AddNodeOptions, opts ...grpc.CallOption) (*pb.Node, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Node
	if rf, ok := ret.Get(0).(func(context.Context, *pb.AddNodeOptions, ...grpc.CallOption) *pb.Node); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.AddNodeOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddPod provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) AddPod(ctx context.Context, in *pb.AddPodOptions, opts ...grpc.CallOption) (*pb.Pod, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Pod
	if rf, ok := ret.Get(0).(func(context.Context, *pb.AddPodOptions, ...grpc.CallOption) *pb.Pod); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Pod)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.AddPodOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BuildImage provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) BuildImage(ctx context.Context, in *pb.BuildImageOptions, opts ...grpc.CallOption) (pb.CoreRPC_BuildImageClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_BuildImageClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.BuildImageOptions, ...grpc.CallOption) pb.CoreRPC_BuildImageClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_BuildImageClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.BuildImageOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CacheImage provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) CacheImage(ctx context.Context, in *pb.CacheImageOptions, opts ...grpc.CallOption) (pb.CoreRPC_CacheImageClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_CacheImageClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.CacheImageOptions, ...grpc.CallOption) pb.CoreRPC_CacheImageClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_CacheImageClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.CacheImageOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateCapacity provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) CalculateCapacity(ctx context.Context, in *pb.DeployOptions, opts ...grpc.CallOption) (*pb.CapacityMessage, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.CapacityMessage
	if rf, ok := ret.Get(0).(func(context.Context, *pb.DeployOptions, ...grpc.CallOption) *pb.CapacityMessage); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.CapacityMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.DeployOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectNetwork provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ConnectNetwork(ctx context.Context, in *pb.ConnectNetworkOptions, opts ...grpc.CallOption) (*pb.Network, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Network
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ConnectNetworkOptions, ...grpc.CallOption) *pb.Network); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Network)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ConnectNetworkOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ControlWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ControlWorkload(ctx context.Context, in *pb.ControlWorkloadOptions, opts ...grpc.CallOption) (pb.CoreRPC_ControlWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_ControlWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ControlWorkloadOptions, ...grpc.CallOption) pb.CoreRPC_ControlWorkloadClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_ControlWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ControlWorkloadOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Copy provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) Copy(ctx context.Context, in *pb.CopyOptions, opts ...grpc.CallOption) (pb.CoreRPC_CopyClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_CopyClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.CopyOptions, ...grpc.CallOption) pb.CoreRPC_CopyClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_CopyClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.CopyOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) CreateWorkload(ctx context.Context, in *pb.DeployOptions, opts ...grpc.CallOption) (pb.CoreRPC_CreateWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_CreateWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.DeployOptions, ...grpc.CallOption) pb.CoreRPC_CreateWorkloadClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_CreateWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.DeployOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisconnectNetwork provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) DisconnectNetwork(ctx context.Context, in *pb.DisconnectNetworkOptions, opts ...grpc.CallOption) (*pb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *pb.DisconnectNetworkOptions, ...grpc.CallOption) *pb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.DisconnectNetworkOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DissociateWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) DissociateWorkload(ctx context.Context, in *pb.DissociateWorkloadOptions, opts ...grpc.CallOption) (pb.CoreRPC_DissociateWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_DissociateWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.DissociateWorkloadOptions, ...grpc.CallOption) pb.CoreRPC_DissociateWorkloadClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_DissociateWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.DissociateWorkloadOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteWorkload provides a mock function with given fields: ctx, opts
func (_m *CoreRPCClient) ExecuteWorkload(ctx context.Context, opts ...grpc.CallOption) (pb.CoreRPC_ExecuteWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_ExecuteWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) pb.CoreRPC_ExecuteWorkloadClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_ExecuteWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNode provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetNode(ctx context.Context, in *pb.GetNodeOptions, opts ...grpc.CallOption) (*pb.Node, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Node
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetNodeOptions, ...grpc.CallOption) *pb.Node); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetNodeOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeResource provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetNodeResource(ctx context.Context, in *pb.GetNodeResourceOptions, opts ...grpc.CallOption) (*pb.NodeResource, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.NodeResource
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetNodeResourceOptions, ...grpc.CallOption) *pb.NodeResource); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.NodeResource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetNodeResourceOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPod provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetPod(ctx context.Context, in *pb.GetPodOptions, opts ...grpc.CallOption) (*pb.Pod, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Pod
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetPodOptions, ...grpc.CallOption) *pb.Pod); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Pod)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetPodOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPodResource provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetPodResource(ctx context.Context, in *pb.GetPodOptions, opts ...grpc.CallOption) (*pb.PodResource, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.PodResource
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetPodOptions, ...grpc.CallOption) *pb.PodResource); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.PodResource)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetPodOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetWorkload(ctx context.Context, in *pb.WorkloadID, opts ...grpc.CallOption) (*pb.Workload, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Workload
	if rf, ok := ret.Get(0).(func(context.Context, *pb.WorkloadID, ...grpc.CallOption) *pb.Workload); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Workload)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.WorkloadID, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkloads provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetWorkloads(ctx context.Context, in *pb.WorkloadIDs, opts ...grpc.CallOption) (*pb.Workloads, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Workloads
	if rf, ok := ret.Get(0).(func(context.Context, *pb.WorkloadIDs, ...grpc.CallOption) *pb.Workloads); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Workloads)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.WorkloadIDs, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkloadsStatus provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) GetWorkloadsStatus(ctx context.Context, in *pb.WorkloadIDs, opts ...grpc.CallOption) (*pb.WorkloadsStatus, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.WorkloadsStatus
	if rf, ok := ret.Get(0).(func(context.Context, *pb.WorkloadIDs, ...grpc.CallOption) *pb.WorkloadsStatus); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.WorkloadsStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.WorkloadIDs, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Info provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) Info(ctx context.Context, in *pb.Empty, opts ...grpc.CallOption) (*pb.CoreInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.CoreInfo
	if rf, ok := ret.Get(0).(func(context.Context, *pb.Empty, ...grpc.CallOption) *pb.CoreInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.CoreInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNetworks provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ListNetworks(ctx context.Context, in *pb.ListNetworkOptions, opts ...grpc.CallOption) (*pb.Networks, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Networks
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ListNetworkOptions, ...grpc.CallOption) *pb.Networks); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Networks)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ListNetworkOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodeWorkloads provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ListNodeWorkloads(ctx context.Context, in *pb.GetNodeOptions, opts ...grpc.CallOption) (*pb.Workloads, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Workloads
	if rf, ok := ret.Get(0).(func(context.Context, *pb.GetNodeOptions, ...grpc.CallOption) *pb.Workloads); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Workloads)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.GetNodeOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPodNodes provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ListPodNodes(ctx context.Context, in *pb.ListNodesOptions, opts ...grpc.CallOption) (*pb.Nodes, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Nodes
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ListNodesOptions, ...grpc.CallOption) *pb.Nodes); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Nodes)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ListNodesOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPods provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ListPods(ctx context.Context, in *pb.Empty, opts ...grpc.CallOption) (*pb.Pods, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Pods
	if rf, ok := ret.Get(0).(func(context.Context, *pb.Empty, ...grpc.CallOption) *pb.Pods); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Pods)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListWorkloads provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ListWorkloads(ctx context.Context, in *pb.ListWorkloadsOptions, opts ...grpc.CallOption) (pb.CoreRPC_ListWorkloadsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_ListWorkloadsClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ListWorkloadsOptions, ...grpc.CallOption) pb.CoreRPC_ListWorkloadsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_ListWorkloadsClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ListWorkloadsOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogStream provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) LogStream(ctx context.Context, in *pb.LogStreamOptions, opts ...grpc.CallOption) (pb.CoreRPC_LogStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_LogStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.LogStreamOptions, ...grpc.CallOption) pb.CoreRPC_LogStreamClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_LogStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.LogStreamOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeStatusStream provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) NodeStatusStream(ctx context.Context, in *pb.Empty, opts ...grpc.CallOption) (pb.CoreRPC_NodeStatusStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_NodeStatusStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.Empty, ...grpc.CallOption) pb.CoreRPC_NodeStatusStreamClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_NodeStatusStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReallocResource provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ReallocResource(ctx context.Context, in *pb.ReallocOptions, opts ...grpc.CallOption) (*pb.ReallocResourceMessage, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.ReallocResourceMessage
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ReallocOptions, ...grpc.CallOption) *pb.ReallocResourceMessage); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.ReallocResourceMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ReallocOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveImage provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) RemoveImage(ctx context.Context, in *pb.RemoveImageOptions, opts ...grpc.CallOption) (pb.CoreRPC_RemoveImageClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_RemoveImageClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.RemoveImageOptions, ...grpc.CallOption) pb.CoreRPC_RemoveImageClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_RemoveImageClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.RemoveImageOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveNode provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) RemoveNode(ctx context.Context, in *pb.RemoveNodeOptions, opts ...grpc.CallOption) (*pb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *pb.RemoveNodeOptions, ...grpc.CallOption) *pb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.RemoveNodeOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemovePod provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) RemovePod(ctx context.Context, in *pb.RemovePodOptions, opts ...grpc.CallOption) (*pb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *pb.RemovePodOptions, ...grpc.CallOption) *pb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.RemovePodOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) RemoveWorkload(ctx context.Context, in *pb.RemoveWorkloadOptions, opts ...grpc.CallOption) (pb.CoreRPC_RemoveWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_RemoveWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.RemoveWorkloadOptions, ...grpc.CallOption) pb.CoreRPC_RemoveWorkloadClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_RemoveWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.RemoveWorkloadOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceWorkload provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) ReplaceWorkload(ctx context.Context, in *pb.ReplaceOptions, opts ...grpc.CallOption) (pb.CoreRPC_ReplaceWorkloadClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_ReplaceWorkloadClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.ReplaceOptions, ...grpc.CallOption) pb.CoreRPC_ReplaceWorkloadClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_ReplaceWorkloadClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.ReplaceOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunAndWait provides a mock function with given fields: ctx, opts
func (_m *CoreRPCClient) RunAndWait(ctx context.Context, opts ...grpc.CallOption) (pb.CoreRPC_RunAndWaitClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_RunAndWaitClient
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) pb.CoreRPC_RunAndWaitClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_RunAndWaitClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Send provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) Send(ctx context.Context, in *pb.SendOptions, opts ...grpc.CallOption) (pb.CoreRPC_SendClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_SendClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SendOptions, ...grpc.CallOption) pb.CoreRPC_SendClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_SendClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.SendOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetNode provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) SetNode(ctx context.Context, in *pb.SetNodeOptions, opts ...grpc.CallOption) (*pb.Node, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Node
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetNodeOptions, ...grpc.CallOption) *pb.Node); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetNodeOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetNodeStatus provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) SetNodeStatus(ctx context.Context, in *pb.SetNodeStatusOptions, opts ...grpc.CallOption) (*pb.Empty, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.Empty
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetNodeStatusOptions, ...grpc.CallOption) *pb.Empty); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Empty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetNodeStatusOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetWorkloadsStatus provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) SetWorkloadsStatus(ctx context.Context, in *pb.SetWorkloadsStatusOptions, opts ...grpc.CallOption) (*pb.WorkloadsStatus, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *pb.WorkloadsStatus
	if rf, ok := ret.Get(0).(func(context.Context, *pb.SetWorkloadsStatusOptions, ...grpc.CallOption) *pb.WorkloadsStatus); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.WorkloadsStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.SetWorkloadsStatusOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchServiceStatus provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) WatchServiceStatus(ctx context.Context, in *pb.Empty, opts ...grpc.CallOption) (pb.CoreRPC_WatchServiceStatusClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_WatchServiceStatusClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.Empty, ...grpc.CallOption) pb.CoreRPC_WatchServiceStatusClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_WatchServiceStatusClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.Empty, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WorkloadStatusStream provides a mock function with given fields: ctx, in, opts
func (_m *CoreRPCClient) WorkloadStatusStream(ctx context.Context, in *pb.WorkloadStatusStreamOptions, opts ...grpc.CallOption) (pb.CoreRPC_WorkloadStatusStreamClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 pb.CoreRPC_WorkloadStatusStreamClient
	if rf, ok := ret.Get(0).(func(context.Context, *pb.WorkloadStatusStreamOptions, ...grpc.CallOption) pb.CoreRPC_WorkloadStatusStreamClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pb.CoreRPC_WorkloadStatusStreamClient)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *pb.WorkloadStatusStreamOptions, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
