package utils

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"os"
	"sort"
	"strconv"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestWritePid(t *testing.T) {
	pidPath, err := ioutil.TempFile(os.TempDir(), "pid-")
	assert.NoError(t, err)

	WritePid(pidPath.Name())

	f, err := os.Open(pidPath.Name())
	assert.NoError(t, err)

	content, err := ioutil.ReadAll(f)
	assert.NoError(t, err)

	pid := strconv.Itoa(os.Getpid())
	assert.Equal(t, pid, string(content))

	os.Remove(pidPath.Name())
}

func TestGetAppInfo(t *testing.T) {
	containerName := "eru-stats_api_EAXPcM"
	name, entrypoint, ident, err := GetAppInfo(containerName)
	assert.NoError(t, err)

	assert.Equal(t, name, "eru-stats")
	assert.Equal(t, entrypoint, "api")
	assert.Equal(t, ident, "EAXPcM")

	containerName = "api_EAXPcM"
	_, _, _, err = GetAppInfo(containerName)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "invalid workload name")
}

func TestPipeWriter_NoBlocking(t *testing.T) {
	r, w := NewBufPipe(10000)
	io.WriteString(w, "abc")
	io.WriteString(w, "def")
	w.Close()

	b, err := ioutil.ReadAll(r)
	assert.NoError(t, err)
	assert.Equal(t, b, []byte("abcdef"))
}

func TestMultiBlocking(t *testing.T) {
	results := make(chan []byte)
	block := func(r io.Reader) {
		b := make([]byte, 3)
		n, err := r.Read(b)
		assert.NoError(t, err)
		results <- b[:n]
	}

	r, w := NewBufPipe(10000)
	go block(r)
	go block(r)
	go block(r)

	time.Sleep(time.Millisecond) // Ensure blocking.

	data := []string{"abc", "def", "ghi"}
	for _, s := range data {
		n, err := w.Write([]byte(s))
		assert.NoError(t, err)
		assert.Equal(t, n, 3)
	}

	var ss []string
	for i := 0; i < 3; i++ {
		ss = append(ss, string(<-results))
	}
	sort.Strings(ss)
	assert.Equal(t, ss, data)
}

func BenchmarkReadOnly(b *testing.B) {
	length := 2
	r, w := NewBufPipe(int64(b.N))
	w.Close()
	data := make([]byte, length)
	io.WriteString(w, string(make([]byte, b.N, b.N)))
	b.ResetTimer()
	for {
		_, err := io.ReadFull(r, data)
		if err != nil {
			if math.Mod(float64(b.N), float64(length)) == 0 {
				assert.EqualError(b, err, "EOF")
			} else {
				assert.EqualError(b, err, "unexpected EOF")
			}
			break
		}
	}
}

func TestReplaceNonUtf8(t *testing.T) {
	str := "test, 1\x00\xff\x01\xbb\xfd\xff\xfd\n"
	assert.Equal(t, "test, 1\\x00\\xff\\x01\\xbb\\xfd\\xff\\xfd\n", ReplaceNonUtf8(str))

	data := []byte{
		0x7b, 0x0a, 0x20, 0x20, 0x22, 0x41, 0x44, 0x44, 0x52, 0x22, 0x3a, 0x20, 0x22, 0x31, 0x30, 0x2e,
		0x31, 0x36, 0x38, 0x2e, 0x33, 0x39, 0x2e, 0x31, 0x39, 0x3a, 0x31, 0x30, 0x30, 0x30, 0x31, 0x22,
		0x2c, 0x0a, 0x20, 0x20, 0x22, 0x43, 0x4d, 0x44, 0x22, 0x3a, 0x20, 0x22, 0x53, 0x45, 0x54, 0x20,
		0x74, 0x63, 0x69, 0x72, 0x5f, 0x53, 0x47, 0x5f, 0x5f, 0x34, 0x37, 0x31, 0x35, 0x5f, 0x70, 0x69,
		0x64, 0x20, 0x5c, 0x74, 0x2c, 0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0x4e, 0xef,
		0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0x3f, 0x5c, 0x75, 0x30, 0x30, 0x31, 0x31, 0x36, 0x5c, 0x75, 0x30,
		0x30, 0x30, 0x37, 0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0x5c, 0x75, 0x30, 0x30,
		0x31, 0x32, 0xef, 0xbf, 0xbd, 0x3f, 0x5c, 0x75, 0x30, 0x30, 0x31, 0x39, 0x41, 0x5c, 0x75, 0x30,
		0x30, 0x31, 0x37, 0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0x55, 0x5b, 0xef, 0xbf, 0xbd, 0x3f, 0x21,
		0xef, 0xbf, 0xbd, 0xef, 0xbf, 0xbd, 0x48, 0xef, 0xbf, 0xbd, 0x27, 0x24, 0xef, 0xbf, 0xbd, 0x3f,
		0x28, 0xef, 0xbf, 0xbd, 0x3f, 0x7e, 0x48, 0xef, 0xbf, 0xbd, 0x5c, 0x75, 0x30, 0x30, 0x30, 0x36,
		0x30, 0xef, 0xbf, 0xbd, 0x29, 0x50, 0x3f, 0x7e, 0x40, 0x5c, 0x75, 0x30, 0x30, 0x30, 0x33, 0x20,
		0x45, 0x58, 0x20, 0x36, 0x30, 0x34, 0x38, 0x30, 0x30, 0x22, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x44,
		0x55, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x22, 0x3a, 0x20, 0x22, 0x31, 0x32, 0x31, 0x39, 0x30,
		0x22, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x49, 0x44, 0x22, 0x3a, 0x20, 0x22, 0x63, 0x6c, 0x75, 0x73,
		0x74, 0x65, 0x72, 0x3a, 0x68, 0x61, 0x6e, 0x71, 0x69, 0x61, 0x6e, 0x67, 0x2e, 0x74, 0x65, 0x73,
		0x74, 0x2e, 0x73, 0x67, 0x37, 0x22, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x4a, 0x52, 0x5f, 0x54, 0x49,
		0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50, 0x22, 0x3a, 0x20, 0x22, 0x31, 0x36, 0x32, 0x37, 0x35,
		0x33, 0x30, 0x33, 0x36, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x22, 0x2c, 0x0a, 0x20, 0x20,
		0x22, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45, 0x22, 0x3a, 0x20, 0x22, 0x73, 0x6c, 0x6f, 0x77,
		0x6c, 0x6f, 0x67, 0x22, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41,
		0x4d, 0x50, 0x22, 0x3a, 0x20, 0x22, 0x31, 0x36, 0x32, 0x37, 0x35, 0x33, 0x30, 0x33, 0x36, 0x37,
		0x22, 0x2c, 0x0a, 0x20, 0x20, 0x22, 0x54, 0x59, 0x50, 0x45, 0x22, 0x3a, 0x20, 0x22, 0x70, 0x72,
		0x6f, 0x78, 0x79, 0x22, 0x0a, 0x7d, 0x0a,
	}
	fmt.Println(ReplaceNonUtf8(string(data)))
}

func TestUseLabelAsFilter(t *testing.T) {
	currentValue := os.Getenv("ERU_AGENT_EXPERIMENTAL_FILTER")
	defer os.Setenv("ERU_AGENT_EXPERIMENTAL_FILTER", currentValue)
	os.Setenv("ERU_AGENT_EXPERIMENTAL_FILTER", "test")
	assert.Equal(t, UseLabelAsFilter(), false)
	os.Setenv("ERU_AGENT_EXPERIMENTAL_FILTER", "label")
	assert.Equal(t, UseLabelAsFilter(), true)
}

func TestGetMaxAttemptsByTTL(t *testing.T) {
	assert.Equal(t, GetMaxAttemptsByTTL(0), 5) // selfmon enabled
	assert.Equal(t, GetMaxAttemptsByTTL(1), 2)
	assert.Equal(t, GetMaxAttemptsByTTL(8), 4) // 0+1+2+4
}

func TestGetIP(t *testing.T) {
	host := "protocol://127.0.0.1:8888888888/some-api?param=none"
	assert.Equal(t, GetIP(host), "127.0.0.1")
	host = "invalid-string"
	assert.Equal(t, GetIP(host), "")
}

func TestWithTimeout(t *testing.T) {
	ctx := context.Background()
	i := 0
	WithTimeout(ctx, time.Second, func(ctx context.Context) {
		select {
		case <-ctx.Done():
			return
		default:
			i = 1
		}
	})

	assert.Equal(t, i, 1)

	WithTimeout(ctx, time.Second, func(ctx context.Context) {
		time.Sleep(2 * time.Second)
		select {
		case <-ctx.Done():
			return
		default:
			i = 2
		}
	})

	assert.NotEqual(t, i, 2)
}
